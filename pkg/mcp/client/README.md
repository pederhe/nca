# MCP Go Client

This package provides a Go implementation of the MCP (Model Control Protocol) client based on [modelcontextprotocol/typescript-sdk](https://github.com/modelcontextprotocol/typescript-sdk). It supports communication with MCP servers using different transport mechanisms, including standard input/output (stdio) and Server-Sent Events (SSE).

Note: Most of the code was generated by Cursor and has not been fully reviewed yet

## Features

- Pluggable transport: Supports standard input/output and SSE transport
- OAuth authentication support
- Complete MCP protocol implementation
- Clean API design

## Basic Usage

```go
package main

import (
	"context"
	"fmt"
	"log"

	"github.com/nca/core/mcp/client"
)

func main() {
	// Create client
	clientInfo := client.ClientImplementation{
		Name:    "My Client",
		Version: "1.0.0",
	}

	options := &client.ClientOptions{
		Capabilities: map[string]interface{}{
			"completion": true,
		},
	}

	c := client.NewClient(clientInfo, options)

	// Create stdio transport
	params := client.StdioServerParameters{
		Command: "mcp-server",
		Args:    []string{"--stdio"},
	}

	transport := client.NewStdioClientTransport(params)

	// Connect to server
	ctx := context.Background()
	if err := c.Connect(ctx, transport); err != nil {
		log.Fatalf("Connection failed: %v", err)
	}
	defer transport.Close()

	// Send completion request
	result, err := c.Complete(ctx, map[string]interface{}{
		"prompt": "How to write efficient code in Go?",
	})
	if err != nil {
		log.Fatalf("Completion request failed: %v", err)
	}

	fmt.Printf("Completion result: %v\n", result)
}
```

## Transport Types

### Standard Input/Output (Stdio)

Stdio transport communicates by spawning a child process and communicating through standard input/output. This is particularly useful for locally running servers.

```go
params := client.StdioServerParameters{
	Command: "mcp-server",
	Args:    []string{"--stdio"},
	Stderr:  os.Stderr, // Optional, defaults to parent process stderr
}

transport := client.NewStdioClientTransport(params)

// Optional: Set error handler
transport.SetErrorHandler(func(err error) {
	fmt.Printf("Transport error: %v\n", err)
})
```

### Server-Sent Events (SSE)

SSE transport uses HTTP long-polling to receive server events and separate HTTP POST requests to send messages. Supports OAuth authentication.

```go
// Create OAuth provider
oauthProvider := &MyOAuthProvider{}

// Parse URL
url, _ := url.Parse("https://api.example.com/mcp/events")

// Create SSE transport
options := &client.SSEClientTransportOptions{
	AuthProvider: oauthProvider,
}

transport := client.NewSSEClientTransport(url, options)
```

## Examples

See the complete example code in the `examples` directory.

## API Reference

### Client

`Client` is the main client class for connecting to MCP servers and sending requests.

```go
// Create new client
client := client.NewClient(clientInfo, options)

// Connect to server
err := client.Connect(ctx, transport)

// Send ping request
err = client.Ping(ctx)

// Send completion request
result, err := client.Complete(ctx, params)

// Set logging level
err = client.SetLoggingLevel(ctx, "debug")

// Get server capabilities
capabilities := client.GetServerCapabilities()
```

### Transport

The transport interface defines methods for communicating with the server:

```go
type Transport interface {
	// Start transport connection
	Start(ctx context.Context) error
	
	// Send message to server
	Send(msg common.JSONRPCMessage) error
	
	// Close connection
	Close() error
	
	// Set message handler
	SetMessageHandler(handler func(common.JSONRPCMessage))
	
	// Set error handler
	SetErrorHandler(handler func(error))
	
	// Set close handler
	SetCloseHandler(handler func())
}
```

## Error Handling

The client uses Go's standard error handling approach, providing specific error types for particular cases.

### Example: Handling Unauthorized Errors

```go
if err := client.Connect(ctx, transport); err != nil {
	var unauthorizedErr *client.UnauthorizedError
	if errors.As(err, &unauthorizedErr) {
		// Handle unauthorized error
		fmt.Println("Reauthorization required")
	} else {
		// Handle other errors
		log.Fatalf("Connection failed: %v", err)
	}
}
```

## Thread Safety

The client and transport implementations are thread-safe and can be used in concurrent environments.

## Dependencies

- Standard library
- `golang.org/x/oauth2` (optional, for OAuth authentication)

## License

Same license as the main project. 